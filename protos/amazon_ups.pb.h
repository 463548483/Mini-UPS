// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: amazon_ups.proto

#ifndef PROTOBUF_INCLUDED_amazon_5fups_2eproto
#define PROTOBUF_INCLUDED_amazon_5fups_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_amazon_5fups_2eproto 

namespace protobuf_amazon_5fups_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_amazon_5fups_2eproto
class AUCommands;
class AUCommandsDefaultTypeInternal;
extern AUCommandsDefaultTypeInternal _AUCommands_default_instance_;
class AULoad;
class AULoadDefaultTypeInternal;
extern AULoadDefaultTypeInternal _AULoad_default_instance_;
class AUPickup;
class AUPickupDefaultTypeInternal;
extern AUPickupDefaultTypeInternal _AUPickup_default_instance_;
class Err;
class ErrDefaultTypeInternal;
extern ErrDefaultTypeInternal _Err_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Package;
class PackageDefaultTypeInternal;
extern PackageDefaultTypeInternal _Package_default_instance_;
class UAArrived;
class UAArrivedDefaultTypeInternal;
extern UAArrivedDefaultTypeInternal _UAArrived_default_instance_;
class UACommands;
class UACommandsDefaultTypeInternal;
extern UACommandsDefaultTypeInternal _UACommands_default_instance_;
class UAConnectWorld;
class UAConnectWorldDefaultTypeInternal;
extern UAConnectWorldDefaultTypeInternal _UAConnectWorld_default_instance_;
class UADeliver;
class UADeliverDefaultTypeInternal;
extern UADeliverDefaultTypeInternal _UADeliver_default_instance_;
class Warehouse;
class WarehouseDefaultTypeInternal;
extern WarehouseDefaultTypeInternal _Warehouse_default_instance_;
namespace google {
namespace protobuf {
template<> ::AUCommands* Arena::CreateMaybeMessage<::AUCommands>(Arena*);
template<> ::AULoad* Arena::CreateMaybeMessage<::AULoad>(Arena*);
template<> ::AUPickup* Arena::CreateMaybeMessage<::AUPickup>(Arena*);
template<> ::Err* Arena::CreateMaybeMessage<::Err>(Arena*);
template<> ::Order* Arena::CreateMaybeMessage<::Order>(Arena*);
template<> ::Package* Arena::CreateMaybeMessage<::Package>(Arena*);
template<> ::UAArrived* Arena::CreateMaybeMessage<::UAArrived>(Arena*);
template<> ::UACommands* Arena::CreateMaybeMessage<::UACommands>(Arena*);
template<> ::UAConnectWorld* Arena::CreateMaybeMessage<::UAConnectWorld>(Arena*);
template<> ::UADeliver* Arena::CreateMaybeMessage<::UADeliver>(Arena*);
template<> ::Warehouse* Arena::CreateMaybeMessage<::Warehouse>(Arena*);
}  // namespace protobuf
}  // namespace google

// ===================================================================

class UAConnectWorld : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UAConnectWorld) */ {
 public:
  UAConnectWorld();
  virtual ~UAConnectWorld();

  UAConnectWorld(const UAConnectWorld& from);

  inline UAConnectWorld& operator=(const UAConnectWorld& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UAConnectWorld(UAConnectWorld&& from) noexcept
    : UAConnectWorld() {
    *this = ::std::move(from);
  }

  inline UAConnectWorld& operator=(UAConnectWorld&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UAConnectWorld& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UAConnectWorld* internal_default_instance() {
    return reinterpret_cast<const UAConnectWorld*>(
               &_UAConnectWorld_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(UAConnectWorld* other);
  friend void swap(UAConnectWorld& a, UAConnectWorld& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UAConnectWorld* New() const final {
    return CreateMaybeMessage<UAConnectWorld>(NULL);
  }

  UAConnectWorld* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UAConnectWorld>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UAConnectWorld& from);
  void MergeFrom(const UAConnectWorld& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UAConnectWorld* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 worldId = 1;
  bool has_worldid() const;
  void clear_worldid();
  static const int kWorldIdFieldNumber = 1;
  ::google::protobuf::int64 worldid() const;
  void set_worldid(::google::protobuf::int64 value);

  // required int64 seqnum = 2;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 2;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UAConnectWorld)
 private:
  void set_has_worldid();
  void clear_has_worldid();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 worldid_;
  ::google::protobuf::int64 seqnum_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UAArrived : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UAArrived) */ {
 public:
  UAArrived();
  virtual ~UAArrived();

  UAArrived(const UAArrived& from);

  inline UAArrived& operator=(const UAArrived& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UAArrived(UAArrived&& from) noexcept
    : UAArrived() {
    *this = ::std::move(from);
  }

  inline UAArrived& operator=(UAArrived&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UAArrived& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UAArrived* internal_default_instance() {
    return reinterpret_cast<const UAArrived*>(
               &_UAArrived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UAArrived* other);
  friend void swap(UAArrived& a, UAArrived& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UAArrived* New() const final {
    return CreateMaybeMessage<UAArrived>(NULL);
  }

  UAArrived* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UAArrived>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UAArrived& from);
  void MergeFrom(const UAArrived& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UAArrived* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 truckId = 1;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckIdFieldNumber = 1;
  ::google::protobuf::int64 truckid() const;
  void set_truckid(::google::protobuf::int64 value);

  // required int64 orderId = 2;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 orderid() const;
  void set_orderid(::google::protobuf::int64 value);

  // required int64 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:UAArrived)
 private:
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 truckid_;
  ::google::protobuf::int64 orderid_;
  ::google::protobuf::int64 seqnum_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Warehouse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Warehouse) */ {
 public:
  Warehouse();
  virtual ~Warehouse();

  Warehouse(const Warehouse& from);

  inline Warehouse& operator=(const Warehouse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Warehouse(Warehouse&& from) noexcept
    : Warehouse() {
    *this = ::std::move(from);
  }

  inline Warehouse& operator=(Warehouse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Warehouse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Warehouse* internal_default_instance() {
    return reinterpret_cast<const Warehouse*>(
               &_Warehouse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Warehouse* other);
  friend void swap(Warehouse& a, Warehouse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Warehouse* New() const final {
    return CreateMaybeMessage<Warehouse>(NULL);
  }

  Warehouse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Warehouse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Warehouse& from);
  void MergeFrom(const Warehouse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Warehouse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 warehouseId = 1;
  bool has_warehouseid() const;
  void clear_warehouseid();
  static const int kWarehouseIdFieldNumber = 1;
  ::google::protobuf::int32 warehouseid() const;
  void set_warehouseid(::google::protobuf::int32 value);

  // required int32 addressX = 2;
  bool has_addressx() const;
  void clear_addressx();
  static const int kAddressXFieldNumber = 2;
  ::google::protobuf::int32 addressx() const;
  void set_addressx(::google::protobuf::int32 value);

  // required int32 addressY = 3;
  bool has_addressy() const;
  void clear_addressy();
  static const int kAddressYFieldNumber = 3;
  ::google::protobuf::int32 addressy() const;
  void set_addressy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Warehouse)
 private:
  void set_has_warehouseid();
  void clear_has_warehouseid();
  void set_has_addressx();
  void clear_has_addressx();
  void set_has_addressy();
  void clear_has_addressy();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 warehouseid_;
  ::google::protobuf::int32 addressx_;
  ::google::protobuf::int32 addressy_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AUPickup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AUPickup) */ {
 public:
  AUPickup();
  virtual ~AUPickup();

  AUPickup(const AUPickup& from);

  inline AUPickup& operator=(const AUPickup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AUPickup(AUPickup&& from) noexcept
    : AUPickup() {
    *this = ::std::move(from);
  }

  inline AUPickup& operator=(AUPickup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AUPickup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AUPickup* internal_default_instance() {
    return reinterpret_cast<const AUPickup*>(
               &_AUPickup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AUPickup* other);
  friend void swap(AUPickup& a, AUPickup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AUPickup* New() const final {
    return CreateMaybeMessage<AUPickup>(NULL);
  }

  AUPickup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AUPickup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AUPickup& from);
  void MergeFrom(const AUPickup& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AUPickup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Warehouse warehouse = 1;
  bool has_warehouse() const;
  void clear_warehouse();
  static const int kWarehouseFieldNumber = 1;
  private:
  const ::Warehouse& _internal_warehouse() const;
  public:
  const ::Warehouse& warehouse() const;
  ::Warehouse* release_warehouse();
  ::Warehouse* mutable_warehouse();
  void set_allocated_warehouse(::Warehouse* warehouse);

  // required int64 orderId = 2;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 orderid() const;
  void set_orderid(::google::protobuf::int64 value);

  // required int64 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AUPickup)
 private:
  void set_has_warehouse();
  void clear_has_warehouse();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::Warehouse* warehouse_;
  ::google::protobuf::int64 orderid_;
  ::google::protobuf::int64 seqnum_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Order* other);
  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(NULL);
  }

  Order* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // required int64 orderId = 1;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  ::google::protobuf::int64 orderid() const;
  void set_orderid(::google::protobuf::int64 value);

  // required int32 destX = 2;
  bool has_destx() const;
  void clear_destx();
  static const int kDestXFieldNumber = 2;
  ::google::protobuf::int32 destx() const;
  void set_destx(::google::protobuf::int32 value);

  // required int32 destY = 3;
  bool has_desty() const;
  void clear_desty();
  static const int kDestYFieldNumber = 3;
  ::google::protobuf::int32 desty() const;
  void set_desty(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Order)
 private:
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_destx();
  void clear_has_destx();
  void set_has_desty();
  void clear_has_desty();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int64 orderid_;
  ::google::protobuf::int32 destx_;
  ::google::protobuf::int32 desty_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AULoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AULoad) */ {
 public:
  AULoad();
  virtual ~AULoad();

  AULoad(const AULoad& from);

  inline AULoad& operator=(const AULoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AULoad(AULoad&& from) noexcept
    : AULoad() {
    *this = ::std::move(from);
  }

  inline AULoad& operator=(AULoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AULoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AULoad* internal_default_instance() {
    return reinterpret_cast<const AULoad*>(
               &_AULoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AULoad* other);
  friend void swap(AULoad& a, AULoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AULoad* New() const final {
    return CreateMaybeMessage<AULoad>(NULL);
  }

  AULoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AULoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AULoad& from);
  void MergeFrom(const AULoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AULoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Order orders = 1;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 1;
  ::Order* mutable_orders(int index);
  ::google::protobuf::RepeatedPtrField< ::Order >*
      mutable_orders();
  const ::Order& orders(int index) const;
  ::Order* add_orders();
  const ::google::protobuf::RepeatedPtrField< ::Order >&
      orders() const;

  // required int64 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // required int32 truckId = 2;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckIdFieldNumber = 2;
  ::google::protobuf::int32 truckid() const;
  void set_truckid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AULoad)
 private:
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Order > orders_;
  ::google::protobuf::int64 seqnum_;
  ::google::protobuf::int32 truckid_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Package : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Package) */ {
 public:
  Package();
  virtual ~Package();

  Package(const Package& from);

  inline Package& operator=(const Package& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Package(Package&& from) noexcept
    : Package() {
    *this = ::std::move(from);
  }

  inline Package& operator=(Package&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Package& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Package* internal_default_instance() {
    return reinterpret_cast<const Package*>(
               &_Package_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Package* other);
  friend void swap(Package& a, Package& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Package* New() const final {
    return CreateMaybeMessage<Package>(NULL);
  }

  Package* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Package>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Package& from);
  void MergeFrom(const Package& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Package* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // required int64 packageId = 1;
  bool has_packageid() const;
  void clear_packageid();
  static const int kPackageIdFieldNumber = 1;
  ::google::protobuf::int64 packageid() const;
  void set_packageid(::google::protobuf::int64 value);

  // required int64 orderId = 2;
  bool has_orderid() const;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 2;
  ::google::protobuf::int64 orderid() const;
  void set_orderid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Package)
 private:
  void set_has_packageid();
  void clear_has_packageid();
  void set_has_orderid();
  void clear_has_orderid();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int64 packageid_;
  ::google::protobuf::int64 orderid_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UADeliver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UADeliver) */ {
 public:
  UADeliver();
  virtual ~UADeliver();

  UADeliver(const UADeliver& from);

  inline UADeliver& operator=(const UADeliver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UADeliver(UADeliver&& from) noexcept
    : UADeliver() {
    *this = ::std::move(from);
  }

  inline UADeliver& operator=(UADeliver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UADeliver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UADeliver* internal_default_instance() {
    return reinterpret_cast<const UADeliver*>(
               &_UADeliver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UADeliver* other);
  friend void swap(UADeliver& a, UADeliver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UADeliver* New() const final {
    return CreateMaybeMessage<UADeliver>(NULL);
  }

  UADeliver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UADeliver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UADeliver& from);
  void MergeFrom(const UADeliver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UADeliver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Package packages = 1;
  int packages_size() const;
  void clear_packages();
  static const int kPackagesFieldNumber = 1;
  ::Package* mutable_packages(int index);
  ::google::protobuf::RepeatedPtrField< ::Package >*
      mutable_packages();
  const ::Package& packages(int index) const;
  ::Package* add_packages();
  const ::google::protobuf::RepeatedPtrField< ::Package >&
      packages() const;

  // required int64 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // required int32 truckid = 2;
  bool has_truckid() const;
  void clear_truckid();
  static const int kTruckidFieldNumber = 2;
  ::google::protobuf::int32 truckid() const;
  void set_truckid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UADeliver)
 private:
  void set_has_truckid();
  void clear_has_truckid();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Package > packages_;
  ::google::protobuf::int64 seqnum_;
  ::google::protobuf::int32 truckid_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Err : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Err) */ {
 public:
  Err();
  virtual ~Err();

  Err(const Err& from);

  inline Err& operator=(const Err& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Err(Err&& from) noexcept
    : Err() {
    *this = ::std::move(from);
  }

  inline Err& operator=(Err&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Err& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Err* internal_default_instance() {
    return reinterpret_cast<const Err*>(
               &_Err_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Err* other);
  friend void swap(Err& a, Err& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Err* New() const final {
    return CreateMaybeMessage<Err>(NULL);
  }

  Err* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Err>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Err& from);
  void MergeFrom(const Err& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Err* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string err = 1;
  bool has_err() const;
  void clear_err();
  static const int kErrFieldNumber = 1;
  const ::std::string& err() const;
  void set_err(const ::std::string& value);
  #if LANG_CXX11
  void set_err(::std::string&& value);
  #endif
  void set_err(const char* value);
  void set_err(const char* value, size_t size);
  ::std::string* mutable_err();
  ::std::string* release_err();
  void set_allocated_err(::std::string* err);

  // required int64 originseqnum = 2;
  bool has_originseqnum() const;
  void clear_originseqnum();
  static const int kOriginseqnumFieldNumber = 2;
  ::google::protobuf::int64 originseqnum() const;
  void set_originseqnum(::google::protobuf::int64 value);

  // required int64 seqnum = 3;
  bool has_seqnum() const;
  void clear_seqnum();
  static const int kSeqnumFieldNumber = 3;
  ::google::protobuf::int64 seqnum() const;
  void set_seqnum(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Err)
 private:
  void set_has_err();
  void clear_has_err();
  void set_has_originseqnum();
  void clear_has_originseqnum();
  void set_has_seqnum();
  void clear_has_seqnum();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr err_;
  ::google::protobuf::int64 originseqnum_;
  ::google::protobuf::int64 seqnum_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UACommands : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UACommands) */ {
 public:
  UACommands();
  virtual ~UACommands();

  UACommands(const UACommands& from);

  inline UACommands& operator=(const UACommands& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UACommands(UACommands&& from) noexcept
    : UACommands() {
    *this = ::std::move(from);
  }

  inline UACommands& operator=(UACommands&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UACommands& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UACommands* internal_default_instance() {
    return reinterpret_cast<const UACommands*>(
               &_UACommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(UACommands* other);
  friend void swap(UACommands& a, UACommands& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UACommands* New() const final {
    return CreateMaybeMessage<UACommands>(NULL);
  }

  UACommands* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UACommands>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UACommands& from);
  void MergeFrom(const UACommands& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UACommands* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UAArrived truckarriveds = 2;
  int truckarriveds_size() const;
  void clear_truckarriveds();
  static const int kTruckarrivedsFieldNumber = 2;
  ::UAArrived* mutable_truckarriveds(int index);
  ::google::protobuf::RepeatedPtrField< ::UAArrived >*
      mutable_truckarriveds();
  const ::UAArrived& truckarriveds(int index) const;
  ::UAArrived* add_truckarriveds();
  const ::google::protobuf::RepeatedPtrField< ::UAArrived >&
      truckarriveds() const;

  // repeated .UADeliver deliveries = 3;
  int deliveries_size() const;
  void clear_deliveries();
  static const int kDeliveriesFieldNumber = 3;
  ::UADeliver* mutable_deliveries(int index);
  ::google::protobuf::RepeatedPtrField< ::UADeliver >*
      mutable_deliveries();
  const ::UADeliver& deliveries(int index) const;
  ::UADeliver* add_deliveries();
  const ::google::protobuf::RepeatedPtrField< ::UADeliver >&
      deliveries() const;

  // repeated .Err uaerrors = 4;
  int uaerrors_size() const;
  void clear_uaerrors();
  static const int kUaerrorsFieldNumber = 4;
  ::Err* mutable_uaerrors(int index);
  ::google::protobuf::RepeatedPtrField< ::Err >*
      mutable_uaerrors();
  const ::Err& uaerrors(int index) const;
  ::Err* add_uaerrors();
  const ::google::protobuf::RepeatedPtrField< ::Err >&
      uaerrors() const;

  // repeated int64 acks = 5;
  int acks_size() const;
  void clear_acks();
  static const int kAcksFieldNumber = 5;
  ::google::protobuf::int64 acks(int index) const;
  void set_acks(int index, ::google::protobuf::int64 value);
  void add_acks(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      acks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_acks();

  // @@protoc_insertion_point(class_scope:UACommands)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UAArrived > truckarriveds_;
  ::google::protobuf::RepeatedPtrField< ::UADeliver > deliveries_;
  ::google::protobuf::RepeatedPtrField< ::Err > uaerrors_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > acks_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AUCommands : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AUCommands) */ {
 public:
  AUCommands();
  virtual ~AUCommands();

  AUCommands(const AUCommands& from);

  inline AUCommands& operator=(const AUCommands& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AUCommands(AUCommands&& from) noexcept
    : AUCommands() {
    *this = ::std::move(from);
  }

  inline AUCommands& operator=(AUCommands&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AUCommands& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AUCommands* internal_default_instance() {
    return reinterpret_cast<const AUCommands*>(
               &_AUCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(AUCommands* other);
  friend void swap(AUCommands& a, AUCommands& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AUCommands* New() const final {
    return CreateMaybeMessage<AUCommands>(NULL);
  }

  AUCommands* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AUCommands>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AUCommands& from);
  void MergeFrom(const AUCommands& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AUCommands* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .AUPickup pickups = 1;
  int pickups_size() const;
  void clear_pickups();
  static const int kPickupsFieldNumber = 1;
  ::AUPickup* mutable_pickups(int index);
  ::google::protobuf::RepeatedPtrField< ::AUPickup >*
      mutable_pickups();
  const ::AUPickup& pickups(int index) const;
  ::AUPickup* add_pickups();
  const ::google::protobuf::RepeatedPtrField< ::AUPickup >&
      pickups() const;

  // repeated .AULoad loads = 2;
  int loads_size() const;
  void clear_loads();
  static const int kLoadsFieldNumber = 2;
  ::AULoad* mutable_loads(int index);
  ::google::protobuf::RepeatedPtrField< ::AULoad >*
      mutable_loads();
  const ::AULoad& loads(int index) const;
  ::AULoad* add_loads();
  const ::google::protobuf::RepeatedPtrField< ::AULoad >&
      loads() const;

  // repeated .Err auerrors = 3;
  int auerrors_size() const;
  void clear_auerrors();
  static const int kAuerrorsFieldNumber = 3;
  ::Err* mutable_auerrors(int index);
  ::google::protobuf::RepeatedPtrField< ::Err >*
      mutable_auerrors();
  const ::Err& auerrors(int index) const;
  ::Err* add_auerrors();
  const ::google::protobuf::RepeatedPtrField< ::Err >&
      auerrors() const;

  // repeated int64 acks = 4;
  int acks_size() const;
  void clear_acks();
  static const int kAcksFieldNumber = 4;
  ::google::protobuf::int64 acks(int index) const;
  void set_acks(int index, ::google::protobuf::int64 value);
  void add_acks(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      acks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_acks();

  // @@protoc_insertion_point(class_scope:AUCommands)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::AUPickup > pickups_;
  ::google::protobuf::RepeatedPtrField< ::AULoad > loads_;
  ::google::protobuf::RepeatedPtrField< ::Err > auerrors_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > acks_;
  friend struct ::protobuf_amazon_5fups_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UAConnectWorld

// required int64 worldId = 1;
inline bool UAConnectWorld::has_worldid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAConnectWorld::set_has_worldid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAConnectWorld::clear_has_worldid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAConnectWorld::clear_worldid() {
  worldid_ = GOOGLE_LONGLONG(0);
  clear_has_worldid();
}
inline ::google::protobuf::int64 UAConnectWorld::worldid() const {
  // @@protoc_insertion_point(field_get:UAConnectWorld.worldId)
  return worldid_;
}
inline void UAConnectWorld::set_worldid(::google::protobuf::int64 value) {
  set_has_worldid();
  worldid_ = value;
  // @@protoc_insertion_point(field_set:UAConnectWorld.worldId)
}

// required int64 seqnum = 2;
inline bool UAConnectWorld::has_seqnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UAConnectWorld::set_has_seqnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UAConnectWorld::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UAConnectWorld::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 UAConnectWorld::seqnum() const {
  // @@protoc_insertion_point(field_get:UAConnectWorld.seqnum)
  return seqnum_;
}
inline void UAConnectWorld::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:UAConnectWorld.seqnum)
}

// -------------------------------------------------------------------

// UAArrived

// required int64 truckId = 1;
inline bool UAArrived::has_truckid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UAArrived::set_has_truckid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UAArrived::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UAArrived::clear_truckid() {
  truckid_ = GOOGLE_LONGLONG(0);
  clear_has_truckid();
}
inline ::google::protobuf::int64 UAArrived::truckid() const {
  // @@protoc_insertion_point(field_get:UAArrived.truckId)
  return truckid_;
}
inline void UAArrived::set_truckid(::google::protobuf::int64 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:UAArrived.truckId)
}

// required int64 orderId = 2;
inline bool UAArrived::has_orderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UAArrived::set_has_orderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UAArrived::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UAArrived::clear_orderid() {
  orderid_ = GOOGLE_LONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::int64 UAArrived::orderid() const {
  // @@protoc_insertion_point(field_get:UAArrived.orderId)
  return orderid_;
}
inline void UAArrived::set_orderid(::google::protobuf::int64 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:UAArrived.orderId)
}

// required int64 seqnum = 3;
inline bool UAArrived::has_seqnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UAArrived::set_has_seqnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UAArrived::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UAArrived::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 UAArrived::seqnum() const {
  // @@protoc_insertion_point(field_get:UAArrived.seqnum)
  return seqnum_;
}
inline void UAArrived::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:UAArrived.seqnum)
}

// -------------------------------------------------------------------

// Warehouse

// required int32 warehouseId = 1;
inline bool Warehouse::has_warehouseid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Warehouse::set_has_warehouseid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Warehouse::clear_has_warehouseid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Warehouse::clear_warehouseid() {
  warehouseid_ = 0;
  clear_has_warehouseid();
}
inline ::google::protobuf::int32 Warehouse::warehouseid() const {
  // @@protoc_insertion_point(field_get:Warehouse.warehouseId)
  return warehouseid_;
}
inline void Warehouse::set_warehouseid(::google::protobuf::int32 value) {
  set_has_warehouseid();
  warehouseid_ = value;
  // @@protoc_insertion_point(field_set:Warehouse.warehouseId)
}

// required int32 addressX = 2;
inline bool Warehouse::has_addressx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Warehouse::set_has_addressx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Warehouse::clear_has_addressx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Warehouse::clear_addressx() {
  addressx_ = 0;
  clear_has_addressx();
}
inline ::google::protobuf::int32 Warehouse::addressx() const {
  // @@protoc_insertion_point(field_get:Warehouse.addressX)
  return addressx_;
}
inline void Warehouse::set_addressx(::google::protobuf::int32 value) {
  set_has_addressx();
  addressx_ = value;
  // @@protoc_insertion_point(field_set:Warehouse.addressX)
}

// required int32 addressY = 3;
inline bool Warehouse::has_addressy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Warehouse::set_has_addressy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Warehouse::clear_has_addressy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Warehouse::clear_addressy() {
  addressy_ = 0;
  clear_has_addressy();
}
inline ::google::protobuf::int32 Warehouse::addressy() const {
  // @@protoc_insertion_point(field_get:Warehouse.addressY)
  return addressy_;
}
inline void Warehouse::set_addressy(::google::protobuf::int32 value) {
  set_has_addressy();
  addressy_ = value;
  // @@protoc_insertion_point(field_set:Warehouse.addressY)
}

// -------------------------------------------------------------------

// AUPickup

// required .Warehouse warehouse = 1;
inline bool AUPickup::has_warehouse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AUPickup::set_has_warehouse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AUPickup::clear_has_warehouse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AUPickup::clear_warehouse() {
  if (warehouse_ != NULL) warehouse_->Clear();
  clear_has_warehouse();
}
inline const ::Warehouse& AUPickup::_internal_warehouse() const {
  return *warehouse_;
}
inline const ::Warehouse& AUPickup::warehouse() const {
  const ::Warehouse* p = warehouse_;
  // @@protoc_insertion_point(field_get:AUPickup.warehouse)
  return p != NULL ? *p : *reinterpret_cast<const ::Warehouse*>(
      &::_Warehouse_default_instance_);
}
inline ::Warehouse* AUPickup::release_warehouse() {
  // @@protoc_insertion_point(field_release:AUPickup.warehouse)
  clear_has_warehouse();
  ::Warehouse* temp = warehouse_;
  warehouse_ = NULL;
  return temp;
}
inline ::Warehouse* AUPickup::mutable_warehouse() {
  set_has_warehouse();
  if (warehouse_ == NULL) {
    auto* p = CreateMaybeMessage<::Warehouse>(GetArenaNoVirtual());
    warehouse_ = p;
  }
  // @@protoc_insertion_point(field_mutable:AUPickup.warehouse)
  return warehouse_;
}
inline void AUPickup::set_allocated_warehouse(::Warehouse* warehouse) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete warehouse_;
  }
  if (warehouse) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      warehouse = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, warehouse, submessage_arena);
    }
    set_has_warehouse();
  } else {
    clear_has_warehouse();
  }
  warehouse_ = warehouse;
  // @@protoc_insertion_point(field_set_allocated:AUPickup.warehouse)
}

// required int64 orderId = 2;
inline bool AUPickup::has_orderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AUPickup::set_has_orderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AUPickup::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AUPickup::clear_orderid() {
  orderid_ = GOOGLE_LONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::int64 AUPickup::orderid() const {
  // @@protoc_insertion_point(field_get:AUPickup.orderId)
  return orderid_;
}
inline void AUPickup::set_orderid(::google::protobuf::int64 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:AUPickup.orderId)
}

// required int64 seqnum = 3;
inline bool AUPickup::has_seqnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AUPickup::set_has_seqnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AUPickup::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AUPickup::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 AUPickup::seqnum() const {
  // @@protoc_insertion_point(field_get:AUPickup.seqnum)
  return seqnum_;
}
inline void AUPickup::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:AUPickup.seqnum)
}

// -------------------------------------------------------------------

// Order

// required int64 orderId = 1;
inline bool Order::has_orderid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Order::set_has_orderid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Order::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Order::clear_orderid() {
  orderid_ = GOOGLE_LONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::int64 Order::orderid() const {
  // @@protoc_insertion_point(field_get:Order.orderId)
  return orderid_;
}
inline void Order::set_orderid(::google::protobuf::int64 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:Order.orderId)
}

// required int32 destX = 2;
inline bool Order::has_destx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Order::set_has_destx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Order::clear_has_destx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Order::clear_destx() {
  destx_ = 0;
  clear_has_destx();
}
inline ::google::protobuf::int32 Order::destx() const {
  // @@protoc_insertion_point(field_get:Order.destX)
  return destx_;
}
inline void Order::set_destx(::google::protobuf::int32 value) {
  set_has_destx();
  destx_ = value;
  // @@protoc_insertion_point(field_set:Order.destX)
}

// required int32 destY = 3;
inline bool Order::has_desty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Order::set_has_desty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Order::clear_has_desty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Order::clear_desty() {
  desty_ = 0;
  clear_has_desty();
}
inline ::google::protobuf::int32 Order::desty() const {
  // @@protoc_insertion_point(field_get:Order.destY)
  return desty_;
}
inline void Order::set_desty(::google::protobuf::int32 value) {
  set_has_desty();
  desty_ = value;
  // @@protoc_insertion_point(field_set:Order.destY)
}

// required string status = 4;
inline bool Order::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Order::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Order::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Order::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& Order::status() const {
  // @@protoc_insertion_point(field_get:Order.status)
  return status_.GetNoArena();
}
inline void Order::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Order.status)
}
#if LANG_CXX11
inline void Order::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Order.status)
}
#endif
inline void Order::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Order.status)
}
inline void Order::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Order.status)
}
inline ::std::string* Order::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:Order.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Order::release_status() {
  // @@protoc_insertion_point(field_release:Order.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Order::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:Order.status)
}

// -------------------------------------------------------------------

// AULoad

// repeated .Order orders = 1;
inline int AULoad::orders_size() const {
  return orders_.size();
}
inline void AULoad::clear_orders() {
  orders_.Clear();
}
inline ::Order* AULoad::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:AULoad.orders)
  return orders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Order >*
AULoad::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:AULoad.orders)
  return &orders_;
}
inline const ::Order& AULoad::orders(int index) const {
  // @@protoc_insertion_point(field_get:AULoad.orders)
  return orders_.Get(index);
}
inline ::Order* AULoad::add_orders() {
  // @@protoc_insertion_point(field_add:AULoad.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Order >&
AULoad::orders() const {
  // @@protoc_insertion_point(field_list:AULoad.orders)
  return orders_;
}

// required int32 truckId = 2;
inline bool AULoad::has_truckid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AULoad::set_has_truckid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AULoad::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AULoad::clear_truckid() {
  truckid_ = 0;
  clear_has_truckid();
}
inline ::google::protobuf::int32 AULoad::truckid() const {
  // @@protoc_insertion_point(field_get:AULoad.truckId)
  return truckid_;
}
inline void AULoad::set_truckid(::google::protobuf::int32 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:AULoad.truckId)
}

// required int64 seqnum = 3;
inline bool AULoad::has_seqnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AULoad::set_has_seqnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AULoad::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AULoad::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 AULoad::seqnum() const {
  // @@protoc_insertion_point(field_get:AULoad.seqnum)
  return seqnum_;
}
inline void AULoad::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:AULoad.seqnum)
}

// -------------------------------------------------------------------

// Package

// required int64 packageId = 1;
inline bool Package::has_packageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Package::set_has_packageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Package::clear_has_packageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Package::clear_packageid() {
  packageid_ = GOOGLE_LONGLONG(0);
  clear_has_packageid();
}
inline ::google::protobuf::int64 Package::packageid() const {
  // @@protoc_insertion_point(field_get:Package.packageId)
  return packageid_;
}
inline void Package::set_packageid(::google::protobuf::int64 value) {
  set_has_packageid();
  packageid_ = value;
  // @@protoc_insertion_point(field_set:Package.packageId)
}

// required int64 orderId = 2;
inline bool Package::has_orderid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Package::set_has_orderid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Package::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Package::clear_orderid() {
  orderid_ = GOOGLE_LONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::int64 Package::orderid() const {
  // @@protoc_insertion_point(field_get:Package.orderId)
  return orderid_;
}
inline void Package::set_orderid(::google::protobuf::int64 value) {
  set_has_orderid();
  orderid_ = value;
  // @@protoc_insertion_point(field_set:Package.orderId)
}

// required string status = 3;
inline bool Package::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Package::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Package::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Package::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& Package::status() const {
  // @@protoc_insertion_point(field_get:Package.status)
  return status_.GetNoArena();
}
inline void Package::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Package.status)
}
#if LANG_CXX11
inline void Package::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Package.status)
}
#endif
inline void Package::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Package.status)
}
inline void Package::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Package.status)
}
inline ::std::string* Package::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:Package.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Package::release_status() {
  // @@protoc_insertion_point(field_release:Package.status)
  if (!has_status()) {
    return NULL;
  }
  clear_has_status();
  return status_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Package::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:Package.status)
}

// -------------------------------------------------------------------

// UADeliver

// repeated .Package packages = 1;
inline int UADeliver::packages_size() const {
  return packages_.size();
}
inline void UADeliver::clear_packages() {
  packages_.Clear();
}
inline ::Package* UADeliver::mutable_packages(int index) {
  // @@protoc_insertion_point(field_mutable:UADeliver.packages)
  return packages_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Package >*
UADeliver::mutable_packages() {
  // @@protoc_insertion_point(field_mutable_list:UADeliver.packages)
  return &packages_;
}
inline const ::Package& UADeliver::packages(int index) const {
  // @@protoc_insertion_point(field_get:UADeliver.packages)
  return packages_.Get(index);
}
inline ::Package* UADeliver::add_packages() {
  // @@protoc_insertion_point(field_add:UADeliver.packages)
  return packages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Package >&
UADeliver::packages() const {
  // @@protoc_insertion_point(field_list:UADeliver.packages)
  return packages_;
}

// required int32 truckid = 2;
inline bool UADeliver::has_truckid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UADeliver::set_has_truckid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UADeliver::clear_has_truckid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UADeliver::clear_truckid() {
  truckid_ = 0;
  clear_has_truckid();
}
inline ::google::protobuf::int32 UADeliver::truckid() const {
  // @@protoc_insertion_point(field_get:UADeliver.truckid)
  return truckid_;
}
inline void UADeliver::set_truckid(::google::protobuf::int32 value) {
  set_has_truckid();
  truckid_ = value;
  // @@protoc_insertion_point(field_set:UADeliver.truckid)
}

// required int64 seqnum = 3;
inline bool UADeliver::has_seqnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UADeliver::set_has_seqnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UADeliver::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UADeliver::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 UADeliver::seqnum() const {
  // @@protoc_insertion_point(field_get:UADeliver.seqnum)
  return seqnum_;
}
inline void UADeliver::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:UADeliver.seqnum)
}

// -------------------------------------------------------------------

// Err

// required string err = 1;
inline bool Err::has_err() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Err::set_has_err() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Err::clear_has_err() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Err::clear_err() {
  err_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_err();
}
inline const ::std::string& Err::err() const {
  // @@protoc_insertion_point(field_get:Err.err)
  return err_.GetNoArena();
}
inline void Err::set_err(const ::std::string& value) {
  set_has_err();
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Err.err)
}
#if LANG_CXX11
inline void Err::set_err(::std::string&& value) {
  set_has_err();
  err_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Err.err)
}
#endif
inline void Err::set_err(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_err();
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Err.err)
}
inline void Err::set_err(const char* value, size_t size) {
  set_has_err();
  err_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Err.err)
}
inline ::std::string* Err::mutable_err() {
  set_has_err();
  // @@protoc_insertion_point(field_mutable:Err.err)
  return err_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Err::release_err() {
  // @@protoc_insertion_point(field_release:Err.err)
  if (!has_err()) {
    return NULL;
  }
  clear_has_err();
  return err_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Err::set_allocated_err(::std::string* err) {
  if (err != NULL) {
    set_has_err();
  } else {
    clear_has_err();
  }
  err_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), err);
  // @@protoc_insertion_point(field_set_allocated:Err.err)
}

// required int64 originseqnum = 2;
inline bool Err::has_originseqnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Err::set_has_originseqnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Err::clear_has_originseqnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Err::clear_originseqnum() {
  originseqnum_ = GOOGLE_LONGLONG(0);
  clear_has_originseqnum();
}
inline ::google::protobuf::int64 Err::originseqnum() const {
  // @@protoc_insertion_point(field_get:Err.originseqnum)
  return originseqnum_;
}
inline void Err::set_originseqnum(::google::protobuf::int64 value) {
  set_has_originseqnum();
  originseqnum_ = value;
  // @@protoc_insertion_point(field_set:Err.originseqnum)
}

// required int64 seqnum = 3;
inline bool Err::has_seqnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Err::set_has_seqnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Err::clear_has_seqnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Err::clear_seqnum() {
  seqnum_ = GOOGLE_LONGLONG(0);
  clear_has_seqnum();
}
inline ::google::protobuf::int64 Err::seqnum() const {
  // @@protoc_insertion_point(field_get:Err.seqnum)
  return seqnum_;
}
inline void Err::set_seqnum(::google::protobuf::int64 value) {
  set_has_seqnum();
  seqnum_ = value;
  // @@protoc_insertion_point(field_set:Err.seqnum)
}

// -------------------------------------------------------------------

// UACommands

// repeated .UAArrived truckarriveds = 2;
inline int UACommands::truckarriveds_size() const {
  return truckarriveds_.size();
}
inline void UACommands::clear_truckarriveds() {
  truckarriveds_.Clear();
}
inline ::UAArrived* UACommands::mutable_truckarriveds(int index) {
  // @@protoc_insertion_point(field_mutable:UACommands.truckarriveds)
  return truckarriveds_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::UAArrived >*
UACommands::mutable_truckarriveds() {
  // @@protoc_insertion_point(field_mutable_list:UACommands.truckarriveds)
  return &truckarriveds_;
}
inline const ::UAArrived& UACommands::truckarriveds(int index) const {
  // @@protoc_insertion_point(field_get:UACommands.truckarriveds)
  return truckarriveds_.Get(index);
}
inline ::UAArrived* UACommands::add_truckarriveds() {
  // @@protoc_insertion_point(field_add:UACommands.truckarriveds)
  return truckarriveds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UAArrived >&
UACommands::truckarriveds() const {
  // @@protoc_insertion_point(field_list:UACommands.truckarriveds)
  return truckarriveds_;
}

// repeated .UADeliver deliveries = 3;
inline int UACommands::deliveries_size() const {
  return deliveries_.size();
}
inline void UACommands::clear_deliveries() {
  deliveries_.Clear();
}
inline ::UADeliver* UACommands::mutable_deliveries(int index) {
  // @@protoc_insertion_point(field_mutable:UACommands.deliveries)
  return deliveries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::UADeliver >*
UACommands::mutable_deliveries() {
  // @@protoc_insertion_point(field_mutable_list:UACommands.deliveries)
  return &deliveries_;
}
inline const ::UADeliver& UACommands::deliveries(int index) const {
  // @@protoc_insertion_point(field_get:UACommands.deliveries)
  return deliveries_.Get(index);
}
inline ::UADeliver* UACommands::add_deliveries() {
  // @@protoc_insertion_point(field_add:UACommands.deliveries)
  return deliveries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UADeliver >&
UACommands::deliveries() const {
  // @@protoc_insertion_point(field_list:UACommands.deliveries)
  return deliveries_;
}

// repeated .Err uaerrors = 4;
inline int UACommands::uaerrors_size() const {
  return uaerrors_.size();
}
inline void UACommands::clear_uaerrors() {
  uaerrors_.Clear();
}
inline ::Err* UACommands::mutable_uaerrors(int index) {
  // @@protoc_insertion_point(field_mutable:UACommands.uaerrors)
  return uaerrors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Err >*
UACommands::mutable_uaerrors() {
  // @@protoc_insertion_point(field_mutable_list:UACommands.uaerrors)
  return &uaerrors_;
}
inline const ::Err& UACommands::uaerrors(int index) const {
  // @@protoc_insertion_point(field_get:UACommands.uaerrors)
  return uaerrors_.Get(index);
}
inline ::Err* UACommands::add_uaerrors() {
  // @@protoc_insertion_point(field_add:UACommands.uaerrors)
  return uaerrors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Err >&
UACommands::uaerrors() const {
  // @@protoc_insertion_point(field_list:UACommands.uaerrors)
  return uaerrors_;
}

// repeated int64 acks = 5;
inline int UACommands::acks_size() const {
  return acks_.size();
}
inline void UACommands::clear_acks() {
  acks_.Clear();
}
inline ::google::protobuf::int64 UACommands::acks(int index) const {
  // @@protoc_insertion_point(field_get:UACommands.acks)
  return acks_.Get(index);
}
inline void UACommands::set_acks(int index, ::google::protobuf::int64 value) {
  acks_.Set(index, value);
  // @@protoc_insertion_point(field_set:UACommands.acks)
}
inline void UACommands::add_acks(::google::protobuf::int64 value) {
  acks_.Add(value);
  // @@protoc_insertion_point(field_add:UACommands.acks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UACommands::acks() const {
  // @@protoc_insertion_point(field_list:UACommands.acks)
  return acks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UACommands::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:UACommands.acks)
  return &acks_;
}

// -------------------------------------------------------------------

// AUCommands

// repeated .AUPickup pickups = 1;
inline int AUCommands::pickups_size() const {
  return pickups_.size();
}
inline void AUCommands::clear_pickups() {
  pickups_.Clear();
}
inline ::AUPickup* AUCommands::mutable_pickups(int index) {
  // @@protoc_insertion_point(field_mutable:AUCommands.pickups)
  return pickups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AUPickup >*
AUCommands::mutable_pickups() {
  // @@protoc_insertion_point(field_mutable_list:AUCommands.pickups)
  return &pickups_;
}
inline const ::AUPickup& AUCommands::pickups(int index) const {
  // @@protoc_insertion_point(field_get:AUCommands.pickups)
  return pickups_.Get(index);
}
inline ::AUPickup* AUCommands::add_pickups() {
  // @@protoc_insertion_point(field_add:AUCommands.pickups)
  return pickups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AUPickup >&
AUCommands::pickups() const {
  // @@protoc_insertion_point(field_list:AUCommands.pickups)
  return pickups_;
}

// repeated .AULoad loads = 2;
inline int AUCommands::loads_size() const {
  return loads_.size();
}
inline void AUCommands::clear_loads() {
  loads_.Clear();
}
inline ::AULoad* AUCommands::mutable_loads(int index) {
  // @@protoc_insertion_point(field_mutable:AUCommands.loads)
  return loads_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::AULoad >*
AUCommands::mutable_loads() {
  // @@protoc_insertion_point(field_mutable_list:AUCommands.loads)
  return &loads_;
}
inline const ::AULoad& AUCommands::loads(int index) const {
  // @@protoc_insertion_point(field_get:AUCommands.loads)
  return loads_.Get(index);
}
inline ::AULoad* AUCommands::add_loads() {
  // @@protoc_insertion_point(field_add:AUCommands.loads)
  return loads_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AULoad >&
AUCommands::loads() const {
  // @@protoc_insertion_point(field_list:AUCommands.loads)
  return loads_;
}

// repeated .Err auerrors = 3;
inline int AUCommands::auerrors_size() const {
  return auerrors_.size();
}
inline void AUCommands::clear_auerrors() {
  auerrors_.Clear();
}
inline ::Err* AUCommands::mutable_auerrors(int index) {
  // @@protoc_insertion_point(field_mutable:AUCommands.auerrors)
  return auerrors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Err >*
AUCommands::mutable_auerrors() {
  // @@protoc_insertion_point(field_mutable_list:AUCommands.auerrors)
  return &auerrors_;
}
inline const ::Err& AUCommands::auerrors(int index) const {
  // @@protoc_insertion_point(field_get:AUCommands.auerrors)
  return auerrors_.Get(index);
}
inline ::Err* AUCommands::add_auerrors() {
  // @@protoc_insertion_point(field_add:AUCommands.auerrors)
  return auerrors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Err >&
AUCommands::auerrors() const {
  // @@protoc_insertion_point(field_list:AUCommands.auerrors)
  return auerrors_;
}

// repeated int64 acks = 4;
inline int AUCommands::acks_size() const {
  return acks_.size();
}
inline void AUCommands::clear_acks() {
  acks_.Clear();
}
inline ::google::protobuf::int64 AUCommands::acks(int index) const {
  // @@protoc_insertion_point(field_get:AUCommands.acks)
  return acks_.Get(index);
}
inline void AUCommands::set_acks(int index, ::google::protobuf::int64 value) {
  acks_.Set(index, value);
  // @@protoc_insertion_point(field_set:AUCommands.acks)
}
inline void AUCommands::add_acks(::google::protobuf::int64 value) {
  acks_.Add(value);
  // @@protoc_insertion_point(field_add:AUCommands.acks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
AUCommands::acks() const {
  // @@protoc_insertion_point(field_list:AUCommands.acks)
  return acks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
AUCommands::mutable_acks() {
  // @@protoc_insertion_point(field_mutable_list:AUCommands.acks)
  return &acks_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_amazon_5fups_2eproto
